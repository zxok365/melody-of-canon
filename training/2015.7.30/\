#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <vector>
#define PII pair<int, int>
using namespace std;
struct course
{
	int s, t, id;
	course() {s = t = id = 0;}
	course(int s, int t, int id) : s(s), t(t), id(id) {}
};
bool cmp1(const course &a, const course &b)
{
	return a.s < b.t;
}
bool cmp2(const course &a, const course &b)
{
	return a.t < b.t;
}
int NN, Index[100005];
PII tree[200005], dp[100005];
vector<int> tot;
course a[100005];
inline int lowbit(int x) {return x & -x;}
PII query(int x)
{
	PII res = PII(0, 0);
	while (x)
	{
		res = max(res, tree[x]);
		x -= lowbit(x);
	}
	return res;
}
void add(int x, PII c)
{
	while (x <= NN)
	{
		tree[x] = max(tree[x], c);
		x += lowbit(x);
	}
}
vector<int> A[100005];
bool in_chain[100005];
int f[100005];
int fat(int x)
{
	if (f[x] == x) return x;
	return f[x] = fat(f[x]);
}
void join(int x, int y)
{
	x = fat(x); y = fat(y);
	f[y] = x;
}
int main()
{
	int n, i, j, k, l;
	while (scanf("%d", &n) == 1)
	{
		tot.clear();
		for (i = 1; i <= n; ++ i)
		{
			scanf("%d%d", &j, &k);
			a[i] = course(j, k, i);
			tot.push_back(j);
			tot.push_back(k);
		}
		sort(tot.begin(), tot.end());
		tot.erase(unique(tot.begin(), tot.end()), tot.end());
		for (i = 1; i <= n; ++ i)
		{
			a[i].s = lower_bound(tot.begin(), tot.end(), a[i].s) + 1;
			a[i].t = lower_bound(tot.begin(), tot.end(), a[i].t) + 1;
		}
		NN = tot.size() + 1;
		memset(tree, 0, sizeof(tree));
		sort(a + 1, a + 1 + n, cmp1);
		for (i = 1; i <= n; ++ i)
		{
			dp[i] = query(a[i].s);
			add(a[i].t, PII(dp[i].first + 1, i));
		}
		int ans = 0, ans_ind;
		for (i = 1; i <= n; ++ i)
		{
			if (ans < dp[i].first)
			{
				ans = dp[i].first;
				ans_ind = dp[i].second;
			}
		}
		for (i = 1; i <= n; ++ i) in_chain[i] = 0;
		vector<course> chain;
		for (i = ans_ind; i; i = dp[i].second)
		{
			in_chain[a[i].id] = 1;
			Index[a[i].id] = chain.size();
			chain.push_back(a[i]);
		}
		reverse(chain.begin(), chain.end());
		sort(a + 1, a + 1 + n, cmp2);
		for (i = 1; i <= n; ++ i) f[i] = i;
		int cur = 0;
		for (i = 1; i <= n; ++ i)
		{
			if (in_chain[a[i].id]) continue;
			while (cur < ans && chain[cur + 1].s < a[i].t) cur ++;
			join(chain[cur].id, a[i].id);
		}
		for (i = 0; i < ans; ++ i) A[i].clear();
		for (i = 1; i <= n; ++ i) A[Index[fat(a[i].id)]].push_back(a[i].id);
		printf("%d\n", ans);
		for (i = 0; i < ans; ++ i)
		{
			for (j = 0; j < A[i].size(); ++ j) printf("%d%c", A[i][j], " \n"[j == A[i].size() - 1]);
		}
		printf("\n");
	}
}

